package linqable

import (
	"fmt"
	"os"
	"reflect"

	"github.com/dave/jennifer/jen"
)

// Linqablize
func Linqablize(t reflect.Type, packageName string) {
	typeName := "Linqable" + t.Name()

	predicateCode := jen.Id("predicate").Func().Call(jen.Id(t.Name())).Id("bool")

	jenFile := jen.NewFile(packageName)
	jenFile.HeaderComment(`Code generated by linqable.go Do NOT EDIT.`)
	jenFile.Line()
	jenFile.Id("type").Id(typeName).Op("[]").Id(t.Name())
	jenFile.Line()

	// #region constructor
	jenFile.Func().Id(fmt.Sprintf("NewLinqable%s", t.Name())).Call(jen.Id("si").Op("[]").Id(t.Name())).Id(typeName).Block(jen.Return(jen.Id("si")))
	// #endregion constructor
	jenFile.Line()

	// #region Where
	jenFile.Func().Call(jen.Id("si").Id(typeName)).Id("Where").Call(predicateCode).Id(typeName).
		Block(jen.Id("res").Op(":=").Op("[]").Id(t.Name()).Op("{}").Line().For(jen.Id("_").Op(",").Id("i").Op(":=").Id("range").Id("si").
			Block(jen.If(jen.Id("predicate(i)")).
				Block(jen.Id("res").Op("=").Id("append(res, i)"))).Line().Return(jen.Id("res"))))

	// #endregion Where
	jenFile.Line()

	// #region Take
	jenFile.Func().Call(jen.Id("si").Id(typeName)).Id("Take").Call(jen.Id("n int")).Id(typeName).
		Block(jen.If(jen.Id("n < 0 || n > len(si)")).
			Block(jen.Panic(jen.Id(`"Linq: Take() out of index"`))).Line().Id("res").Op(":=").Op("[]").Id(t.Name()).Op("{}").Line().For(jen.Id("i := 0; i < n; i++")).
			Block(jen.Id("res = append(res, si[i])")).Line().Return(jen.Id("res")))
	// #endregion Take
	jenFile.Line()

	// #region TakeWhile
	jenFile.Func().Call(jen.Id("si").Id(typeName)).Id("TakeWhile").Call(predicateCode).Id(typeName).
		Block(jen.Id("res").Op(":=").Op("[]").Id(t.Name()).Op("{}").Line().For(jen.Id("i := 0; i < len(si); i++")).
			Block(jen.If(jen.Id("predicate(si[i])").
				Block(jen.Id("res = append(res, si[i])")).Else().
				Block(jen.Return(jen.Id("res"))))).Line().Return(jen.Id("res")))
	// #endregion TakeWhile
	jenFile.Line()

	// #region Skip
	jenFile.Func().Call(jen.Id("si").Id(typeName)).Id("Skip").Call(jen.Id("n int")).Id(typeName).
		Block(jen.If(jen.Id("n < 0 || n > len(si)")).
			Block(jen.Panic(jen.Id(`"Linq: Skip() out of index"`))).Line().Return(jen.Id("si[n:]")))
	// #endregion Skip
	jenFile.Line()

	// #region SkipWhile
	jenFile.Func().Call(jen.Id("si").Id(typeName)).Id("SkipWhile").Call(predicateCode).Id(typeName).
		Block(jen.For(jen.Id("i := 0; i < len(si); i++")).
			Block(jen.If(jen.Id("predicate(si[i])").
				Block(jen.Op("continue")).Else().
				Block(jen.Return(jen.Id("si[i:]"))))).Line().Return(jen.Id(fmt.Sprintf("%s{}", typeName))))
	// #endregion SkipWhile
	jenFile.Line()

	// #region ToSlice
	jenFile.Func().Call(jen.Id("si").Id(typeName)).Id("ToSlice").Call().Op("[]").Id(t.Name()).Block(jen.Return(jen.Id("si")))
	// #endregion ToSlice

	file, err := os.Create(fmt.Sprintf("linqable_%s.go", t.Name()))
	if err != nil {
		fmt.Println(err)
	}
	defer file.Close()
	file.WriteString(fmt.Sprintf("%#v", jenFile))
}
