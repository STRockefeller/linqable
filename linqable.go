package linqable

import (
	"fmt"
	"os"
	"reflect"

	"github.com/dave/jennifer/jen"
)

// Linqablize
func Linqablize(t reflect.Type, packageName string) {
	typeName := "Linqable" + t.Name()
	jenFile := jen.NewFile(packageName)
	jenFile.HeaderComment(`Code generated by linqable.go Do NOT EDIT.`)
	jenFile.Line()
	jenFile.Id("type").Id(typeName).Op("[]").Id(t.Name())
	jenFile.Line()

	// #region Where
	jenFile.Func().Call(jen.Id("si").Id(typeName)).Id("Where").Call(jen.Id("predicate").Func().Call(jen.Id(t.Name())).Id("bool")).Id(typeName).
		Block(jen.Id("res").Op(":=").Op("[]").Id(t.Name()).Op("{}").Line().For(jen.Id("_").Op(",").Id("i").Op(":=").Id("range").Id("si").
			Block(jen.If(jen.Id("predicate(i)")).
				Block(jen.Id("res").Op("=").Id("append(res, i)"))).Line().Return(jen.Id("res"))))

	// #endregion Where

	jenFile.Func().Call(jen.Id("si").Id(typeName)).Id("ToSlice").Call().Op("[]").Id(t.Name()).Block(jen.Return(jen.Id("si")))

	file, err := os.Create(fmt.Sprintf("linqable_%s.go", t.Name()))
	if err != nil {
		fmt.Println(err)
	}
	defer file.Close()
	file.WriteString(fmt.Sprintf("%#v", jenFile))
}
