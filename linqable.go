package linqable

import (
	"fmt"
	"os"
	"reflect"

	"github.com/dave/jennifer/jen"
)

// Linqablize : generate a new `.go` file with specified type
//
// Parameters
//
// t reflect.Type               => the specified type
//
// packageName string           => package name of the `.go` file
//
// opts ...LinqablizeOptionFunc => optional parameters
//
// Optional Parameters
//
// IsImportedType() => output file will import the package of the specified type
//
// IsNumericType() => output file will contain the methods such as Max(), Min() ...
//
// HasDefaultValue(stringValue string) => Set default value of your type, or using zero value as default.
func Linqablize(t reflect.Type, packageName string, opts ...LinqablizeOptionFunc) {
	var opt linqablizeOption
	for _, optFunc := range opts {
		optFunc(&opt)
	}

	linqableTypeName := "Linqable" + t.Name()
	typeName := t.Name()

	jenFile := jen.NewFile(packageName)
	jenFile.HeaderComment(`Code generated by github.com/STRockefeller/linqable Do NOT EDIT.`)
	// #region imported type
	if opt.isImportedType {
		typeName = t.String()
		jenFile.Id("import").Id("\"" + t.PkgPath() + "\"").Line()
	}
	// #endregion imported type
	jenFile.Id(`import "fmt"`).Line()
	jenFile.Id(`import "reflect"`).Line()
	jenFile.Id(`import "sort"`).Line()
	var defaultValueCode string
	if opt.hasDefaultValue {
		defaultValueCode = "defaultValue := " + opt.defaultValue
	} else {
		defaultValueCode = "var defaultValue " + typeName
	}
	predicateCode := jen.Id("predicate").Func().Call(jen.Id(typeName)).Id("bool")

	jenFile.Line()
	jenFile.Commentf("%s definition", linqableTypeName)
	jenFile.Id("type").Id(linqableTypeName).Op("[]").Id(typeName)
	jenFile.Line()

	// #region constructor
	jenFile.Comment(fmt.Sprintf("NewLinqable%s returns a new %s from the input %s", t.Name(), linqableTypeName, typeName))
	jenFile.Func().Id(fmt.Sprintf("NewLinqable%s", t.Name())).Call(jen.Id("si").Op("[]").Id(typeName)).Id(linqableTypeName).Block(jen.Return(jen.Id("si")))
	// #endregion constructor
	jenFile.Line()

	// #region Repeat
	jenFile.Commentf("Repeat%s generates a sequence that contains one repeated value.", linqableTypeName)
	jenFile.Func().Id(fmt.Sprintf("Repeat%s", linqableTypeName)).Call(jen.Id(fmt.Sprintf("element %s, count int", typeName))).Id(linqableTypeName).
		Block(jen.Id(fmt.Sprintf("si := New%s([]%s{})", linqableTypeName, typeName)).
			Line().For(jen.Id("i := 0; i < count; i++")).
			Block(jen.Id("si = si.Append(element)")).
			Line().Return(jen.Id("si")))
	// #endregion Repeat
	jenFile.Line()

	// #region Where
	jenFile.Comment("Where filters a sequence of values based on a predicate.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("Where").Call(predicateCode).Id(linqableTypeName).
		Block(jen.Id("res").Op(":=").Op("[]").Id(typeName).Op("{}").
			Line().For(jen.Id("_").Op(",").Id("elem").Op(":=").Id("range").Id("si").
			Block(jen.If(jen.Id("predicate(elem)")).
				Block(jen.Id("res").Op("=").Id("append(res, elem)"))).
			Line().Return(jen.Id("res"))))
	// #endregion Where
	jenFile.Line()

	// #region Reverse
	jenFile.Comment("Reverse inverts the order of the elements in a sequence.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("Reverse").Call(predicateCode).Id(linqableTypeName).
		Block(jen.Id(fmt.Sprintf("res := New%s(make([]%s, len(si)))", linqableTypeName, typeName)).
			Line().For(jen.Id("i, j := 0, len(si)-1; i < j; i, j = i+1, j-1")).Block(jen.Id("res[i], res[j] = si[j], si[i]")).
			Line().Return(jen.Id("res")))
	// #endregion Reverse
	jenFile.Line()

	// #region Contains
	jenFile.Comment("Contains determines whether a sequence contains a specified element.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("Contains").Call(jen.Id("target").Id(typeName)).Id("bool").
		Block(jen.For(jen.Id("_").Op(",").Id("elem").Op(":=").Id("range").Id("si").
			Block(jen.If(jen.Id("reflect.DeepEqual(elem, target)")).
				Block(jen.Return(jen.Id("true")))).
			Line().Return(jen.Id("false"))))
	// #endregion Contains
	jenFile.Line()

	// #region Count
	jenFile.Comment("Count returns  a number that represents how many elements in the specified sequence satisfy a condition.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("Count").Call(predicateCode).Id("int").
		Block(jen.Id("var count int").
			Line().For(jen.Id("_").Op(",").Id("elem").Op(":=").Id("range").Id("si").
			Block(jen.If(jen.Id("predicate(elem)")).
				Block(jen.Id("count++"))).
			Line().Return(jen.Id("count"))))
	// #endregion Count
	jenFile.Line()

	// #region Any
	jenFile.Comment("Any determines whether any element of a sequence satisfies a condition.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("Any").Call(predicateCode).Id("bool").
		Block(jen.For(jen.Id("_").Op(",").Id("elem").Op(":=").Id("range").Id("si").
			Block(jen.If(jen.Id("predicate(elem)")).
				Block(jen.Return(jen.Id("true")))).
			Line().Return(jen.Id("false"))))
	// #endregion Any
	jenFile.Line()

	// #region All
	jenFile.Comment("All determines whether all elements of a sequence satisfy a condition.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("All").Call(predicateCode).Id("bool").
		Block(jen.For(jen.Id("_").Op(",").Id("elem").Op(":=").Id("range").Id("si").
			Block(jen.If(jen.Id("predicate(elem)")).
				Block(jen.Continue()).Else().
				Block(jen.Return(jen.Id("false")))).
			Line().Return(jen.Id("true"))))
	// #endregion All
	jenFile.Line()

	// #region Append
	jenFile.Comment("Append appends a value to the end of the sequence.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("Append").Call(jen.Id("newItem").Id(typeName)).Id(linqableTypeName).
		Block(jen.Return(jen.Id("append(si, newItem)")))
	// #endregion Append
	jenFile.Line()

	// #region Prepend
	jenFile.Comment("Prepend adds a value to the beginning of the sequence.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("Prepend").Call(jen.Id("newItem").Id(typeName)).Id(linqableTypeName).
		Block(jen.Return(jen.Id("append").Call(jen.Op("[]").Id(typeName).Id("{newItem}").Id(", si.ToSlice()..."))))
	// #endregion Prepend
	jenFile.Line()

	// #region Distinct
	jenFile.Comment("Distinct returns distinct elements from a sequence by using the default equality comparer to compare values.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("Distinct").Call().Id(linqableTypeName).
		Block(jen.Id("res := si.Empty()").
			Line().For(jen.Id("_, elem := range si")).
			Block(jen.If(jen.Id("!res.Contains(elem)")).
				Block(jen.Id("res = res.Append(elem)"))).
			Line().Return(jen.Id("res")))
	// #endregion Distinct
	jenFile.Line()

	// #region ElementAt
	jenFile.Comment("ElementAt returns the element at a specified index in a sequence." +
		"\r\n\r\n panic:" + "\r\n  - linq: ElementAt() out of index")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("ElementAt").Call(jen.Id("index int")).Id(typeName).
		Block(jen.If(jen.Id("index >= len(si)")).
			Block(jen.Id(`panic("linq: ElementAt() out of index")`)).
			Line().Return(jen.Id("si[index]")))
	// #endregion ElementAt
	jenFile.Line()

	// #region ElementAtOrDefault
	jenFile.Comment("ElementAtOrDefault returns the element at a specified index in a sequence or a default value if the index is out of range.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("ElementAtOrDefault").Call(jen.Id("index int")).Id(typeName).
		Block(jen.Id(defaultValueCode).
			Line().If(jen.Id("index >= len(si)")).
			Block(jen.Return(jen.Id("defaultValue"))).
			Line().Return(jen.Id("si[index]")))
	// #endregion ElementAtOrDefault
	jenFile.Line()

	// #region Empty
	jenFile.Commentf("Empty returns empty %s that has the specified type argument.", linqableTypeName)
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("Empty").Call().Id(linqableTypeName).
		Block(jen.Return(jen.Id("New" + linqableTypeName).Call(jen.Op("[]").Id(typeName).Op("{}"))))
	// #endregion Empty
	jenFile.Line()

	// #region First
	jenFile.Comment("First returns the first element in a sequence that satisfies a specified condition." +
		"\r\n\r\n panic:" + "\r\n  - linq: First() empty set" + "\r\n  - linq: First() no match element in the slice")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("First").Call(predicateCode).Id(typeName).
		Block(jen.If(jen.Id("len(si) <= 0")).
			Block(jen.Panic(jen.Id(`"linq: First() empty set"`))).
			Line().For(jen.Id("_").Op(",").Id("elem").Op(":=").Id("range").Id("si").
			Block(jen.If(jen.Id("predicate(elem)")).
				Block(jen.Return(jen.Id("elem")))).
			Line().Panic(jen.Id(`"linq: First() no match element in the slice"`))))
	// #endregion First
	jenFile.Line()

	// #region FirstOrDefault
	jenFile.Comment("FirstOrDefault returns the first element of a sequence, or a default value if the sequence contains no elements.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("FirstOrDefault").Call(predicateCode).Id(typeName).
		Block(jen.Id(defaultValueCode).
			Line().If(jen.Id("len(si) <= 0")).
			Block(jen.Return(jen.Id("defaultValue"))).
			Line().For(jen.Id("_").Op(",").Id("elem").Op(":=").Id("range").Id("si").
			Block(jen.If(jen.Id("predicate(elem)")).
				Block(jen.Return(jen.Id("elem")))).
			Line().Return(jen.Id("defaultValue"))))
	// #endregion FirstOrDefault
	jenFile.Line()

	// #region Last
	jenFile.Comment("Last returns the last element in a sequence that satisfies a specified condition." +
		"\r\n\r\n panic:" + "\r\n  - linq: Last() empty set" + "\r\n  - linq: Last() no match element in the slice")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("Last").Call(predicateCode).Id(typeName).
		Block(jen.If(jen.Id("len(si) <= 0")).
			Block(jen.Panic(jen.Id(`"linq: Last() empty set"`))).
			Line().For(jen.Id("i := len(si) - 1; i >= 0; i--")).
			Block(jen.If(jen.Id("predicate(si[i])")).
				Block(jen.Return(jen.Id("si[i]")))).
			Line().Panic(jen.Id(`"linq: Last() no match element in the slice"`)))
	// #endregion Last
	jenFile.Line()

	// #region LastOrDefault
	jenFile.Comment("LastOrDefault returns the last element of a sequence, or a default value if the sequence contains no elements.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("LastOrDefault").Call(predicateCode).Id(typeName).
		Block(jen.Id(defaultValueCode).
			Line().If(jen.Id("len(si) <= 0")).
			Block(jen.Return(jen.Id("defaultValue"))).
			Line().For(jen.Id("i := len(si) - 1; i >= 0; i--")).
			Block(jen.If(jen.Id("predicate(si[i])")).
				Block(jen.Return(jen.Id("si[i]")))).
			Line().Return(jen.Id("defaultValue")))
	// #endregion LastOrDefault
	jenFile.Line()

	// #region Single
	jenFile.Comment("Single returns the only element of a sequence that satisfies a specified condition, and returns a panic if more than one such element exists.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("Single").Call(predicateCode).Id(typeName).
		Block(jen.If(jen.Id("len(si) <= 0")).
			Block(jen.Panic(jen.Id(`"linq: Single() empty set"`))).
			Line().If(jen.Id("si.Count(predicate) == 1")).
			Block(jen.Return(jen.Id("si.First(predicate)"))).
			Line().Panic(jen.Id(`"linq: Single() eligible data count is not unique"`)))
	// #endregion Single
	jenFile.Line()

	// #region SingleOrDefault
	jenFile.Comment("SingleOrDefault returns the only element of a sequence, or a default value if the sequence is empty; this method returns a panic if there is more than one element in the sequence.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("SingleOrDefault").Call(predicateCode).Id(typeName).
		Block(jen.Id(defaultValueCode).
			Line().If(jen.Id("len(si) <= 0")).
			Block(jen.Return(jen.Id("defaultValue"))).
			Line().If(jen.Id("si.Count(predicate) == 1")).
			Block(jen.Return(jen.Id("si.First(predicate)"))).
			Line().Panic(jen.Id(`"linq: SingleOrDefault() eligible data count is not unique"`)))
	// #endregion SingleOrDefault
	jenFile.Line()

	// #region Take
	jenFile.Comment("Take returns a specified number of contiguous elements from the start of a sequence." +
		"\r\n\r\n panic:" + "\r\n  - Linq: Take() out of index")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("Take").Call(jen.Id("n int")).Id(linqableTypeName).
		Block(jen.If(jen.Id("n < 0 || n >= len(si)")).
			Block(jen.Panic(jen.Id(`"Linq: Take() out of index"`))).
			Line().Id("res").Op(":=").Op("[]").Id(typeName).Op("{}").
			Line().For(jen.Id("i := 0; i < n; i++")).
			Block(jen.Id("res = append(res, si[i])")).
			Line().Return(jen.Id("res")))
	// #endregion Take
	jenFile.Line()

	// #region TakeWhile
	jenFile.Comment("TakeWhile returns elements from a sequence as long as a specified condition is true, and then skips the remaining elements.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("TakeWhile").Call(predicateCode).Id(linqableTypeName).
		Block(jen.Id("res").Op(":=").Op("[]").Id(typeName).Op("{}").
			Line().For(jen.Id("i := 0; i < len(si); i++")).
			Block(jen.If(jen.Id("predicate(si[i])").
				Block(jen.Id("res = append(res, si[i])")).Else().
				Block(jen.Return(jen.Id("res"))))).
			Line().Return(jen.Id("res")))
	// #endregion TakeWhile
	jenFile.Line()

	// #region TakeLast
	jenFile.Commentf("TakeLast returns a new %s that contains the last count elements from source."+
		"\r\n\r\n panic:"+"\r\n  - Linq: TakeLast() out of index", linqableTypeName)
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("TakeLast").Call(jen.Id("n int")).Id(linqableTypeName).
		Block(jen.If(jen.Id("n < 0 || n >= len(si)")).
			Block(jen.Panic(jen.Id(`"Linq: TakeLast() out of index"`))).
			Line().Return(jen.Id("si.Skip(len(si) - n)")))
	// #endregion TakeLast
	jenFile.Line()

	// #region Skip
	jenFile.Comment("Skip bypasses a specified number of elements in a sequence and then returns the remaining elements." +
		"\r\n\r\n panic:" + "\r\n  - Linq: Skip() out of index")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("Skip").Call(jen.Id("n int")).Id(linqableTypeName).
		Block(jen.If(jen.Id("n < 0 || n >= len(si)")).
			Block(jen.Panic(jen.Id(`"Linq: Skip() out of index"`))).
			Line().Return(jen.Id("si[n:]")))
	// #endregion Skip
	jenFile.Line()

	// #region SkipWhile
	jenFile.Comment("SkipWhile bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("SkipWhile").Call(predicateCode).Id(linqableTypeName).
		Block(jen.For(jen.Id("i := 0; i < len(si); i++")).
			Block(jen.If(jen.Id("predicate(si[i])").
				Block(jen.Op("continue")).Else().
				Block(jen.Return(jen.Id("si[i:]"))))).
			Line().Return(jen.Id(fmt.Sprintf("%s{}", linqableTypeName))))
	// #endregion SkipWhile
	jenFile.Line()

	// #region SkipLast
	jenFile.Comment("SkipLast returns a new enumerable collection that contains the elements from source with the last count elements of the source collection omitted." +
		"\r\n\r\n panic:" + "\r\n  - Linq: SkipLast() out of index")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("SkipLast").Call(jen.Id("n int")).Id(linqableTypeName).
		Block(jen.If(jen.Id("n < 0 || n > len(si)")).
			Block(jen.Panic(jen.Id(`"Linq: SkipLast() out of index"`))).
			Line().Return(jen.Id("si.Take(len(si) - n)")))
	// #endregion SkipLast
	jenFile.Line()

	// #region OrderBy
	jenFile.Comment("OrderBy sorts the elements of a sequence in ascending order according to a key.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("OrderBy").Call(jen.Id(fmt.Sprintf("comparer func(%s) int", typeName))).Id(linqableTypeName).
		Block(jen.Id("sort.SliceStable").Call(jen.Id("si, func(i, j int) bool").
			Block(jen.Return(jen.Id("comparer(si[i]) > comparer(si[j])")))).
			Line().Return(jen.Id("si")))
	// #endregion OrderBy
	jenFile.Line()

	// #region OrderByDescending
	jenFile.Comment("OrderByDescending sorts the elements of a sequence in descending order according to a key.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("OrderByDescending").Call(jen.Id(fmt.Sprintf("comparer func(%s) int", typeName))).Id(linqableTypeName).
		Block(jen.Id("sort.SliceStable").Call(jen.Id("si, func(i, j int) bool").
			Block(jen.Return(jen.Id("comparer(si[i]) < comparer(si[j])")))).
			Line().Return(jen.Id("si")))
	// #endregion OrderByDescending
	jenFile.Line()

	// #region SumInt32
	jenFile.Comment("SumInt32 computes the sum of a sequence of numeric values.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("SumInt32").Call(jen.Id(fmt.Sprintf("selector func(%s) int32", typeName))).Id("int32").
		Block(jen.Id("var sum int32").
			Line().For(jen.Id("_, elem := range si")).Block(jen.Id("sum += selector(elem)")).
			Line().Return(jen.Id("sum")))
	// #endregion SumInt
	jenFile.Line()

	// #region SumInt16
	jenFile.Comment("SumInt16 computes the sum of a sequence of numeric values.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("SumInt16").Call(jen.Id(fmt.Sprintf("selector func(%s) int16", typeName))).Id("int16").
		Block(jen.Id("var sum int16").
			Line().For(jen.Id("_, elem := range si")).Block(jen.Id("sum += selector(elem)")).
			Line().Return(jen.Id("sum")))
	// #endregion SumInt16
	jenFile.Line()

	// #region SumInt64
	jenFile.Comment("SumInt64 computes the sum of a sequence of numeric values.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("SumInt64").Call(jen.Id(fmt.Sprintf("selector func(%s) int64", typeName))).Id("int64").
		Block(jen.Id("var sum int64").
			Line().For(jen.Id("_, elem := range si")).Block(jen.Id("sum += selector(elem)")).
			Line().Return(jen.Id("sum")))
	// #endregion SumInt64
	jenFile.Line()

	// #region SumFloat32
	jenFile.Comment("SumFloat32 computes the sum of a sequence of numeric values.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("SumFloat32").Call(jen.Id(fmt.Sprintf("selector func(%s) float32", typeName))).Id("float32").
		Block(jen.Id("var sum float32").
			Line().For(jen.Id("_, elem := range si")).Block(jen.Id("sum += selector(elem)")).
			Line().Return(jen.Id("sum")))
	// #endregion SumFloat32
	jenFile.Line()

	// #region SumFloat64
	jenFile.Comment("SumFloat64 computes the sum of a sequence of numeric values.")
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("SumFloat64").Call(jen.Id(fmt.Sprintf("selector func(%s) float64", typeName))).Id("float64").
		Block(jen.Id("var sum float64").
			Line().For(jen.Id("_, elem := range si")).Block(jen.Id("sum += selector(elem)")).
			Line().Return(jen.Id("sum")))
	// #endregion SumFloat64
	jenFile.Line()

	// #region ToSlice
	jenFile.Commentf("ToSlice create a/an %s slice from a/an %s", typeName, typeName)
	jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("ToSlice").Call().Op("[]").Id(typeName).
		Block(jen.Id(fmt.Sprintf("res := make([]%s, len(si))", typeName)).
			Line().For(jen.Id("i, elem := range si")).
			Block(jen.Id("res[i] = elem")).
			Line().Return(jen.Id("res")))
	// #endregion ToSlice

	if opt.isNumericType {
		// #region Max
		jenFile.Comment("Max returns the maximum value in a sequence of values.")
		jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("Max").Call().Id(typeName).
			Block(jen.Id("var max").Id(typeName).
				Line().For(jen.Id("i, elem := range si")).
				Block(jen.If(jen.Id("i == 0 || elem > max")).
					Block(jen.Id("max = elem"))).
				Line().Return(jen.Id("max")))
		// #endregion Max
		jenFile.Line()

		// #region Min
		jenFile.Comment("Min returns the minimum value in a sequence of values.")
		jenFile.Func().Call(jen.Id("si").Id(linqableTypeName)).Id("Min").Call().Id(typeName).
			Block(jen.Id("var min").Id(typeName).
				Line().For(jen.Id("i, elem := range si")).
				Block(jen.If(jen.Id("i == 0 || elem < min")).
					Block(jen.Id("min = elem"))).
				Line().Return(jen.Id("min")))
		// #endregion Min
		jenFile.Line()
	}

	jenFile.Comment("#region not linq")
	jenFile.Line()

	// #region Add
	jenFile.Commentf("Add adds an object to the end of the %s.", linqableTypeName)

	jenFile.Func().Call(jen.Id(fmt.Sprint("si *", linqableTypeName))).Id("Add").Params(jen.Id("element").Id(typeName)).
		Block(jen.Id("*si = append(*si, element)"))
	// #endregion Add
	jenFile.Line()

	// #region AddRange
	jenFile.Commentf("AddRange adds the elements of the specified collection to the end of the %s.", linqableTypeName)

	jenFile.Func().Call(jen.Id(fmt.Sprint("si *", linqableTypeName))).Id("AddRange").Params(jen.Id("collection").Id(linqableTypeName)).
		Block(jen.Id("*si = append(*si, collection...)"))
	// #endregion AddRange
	jenFile.Line()

	// #region Clear
	jenFile.Commentf("Clear removes all elements from the %s.", linqableTypeName)

	jenFile.Func().Call(jen.Id(fmt.Sprint("si *", linqableTypeName))).Id("Clear").Params().
		Block(jen.Id(fmt.Sprintf("*si = New%s(make([]%s, cap(si.ToSlice())))", linqableTypeName, typeName)))
	// #endregion Clear
	jenFile.Line()

	// #region Clone
	jenFile.Commentf("Clone copies the %s to a new %s", linqableTypeName, linqableTypeName)

	jenFile.Func().Call(jen.Id(fmt.Sprint("si ", linqableTypeName))).Id("Clone").Params().Id(linqableTypeName).
		Block(jen.Return(jen.Id("si.ToSlice()")))
	// #endregion Clone
	jenFile.Line()

	// #region Exists
	jenFile.Commentf("Exists determines whether the %s contains elements that match the conditions defined by the specified predicate.", linqableTypeName)

	jenFile.Func().Call(jen.Id(fmt.Sprint("si ", linqableTypeName))).Id("Exists").Params(predicateCode).Id("bool").
		Block(jen.Id("return si.Any(predicate)"))
	// #endregion Exists
	jenFile.Line()

	// #region Find
	jenFile.Commentf("Find searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire %s.", linqableTypeName)

	jenFile.Func().Call(jen.Id(fmt.Sprint("si ", linqableTypeName))).Id("Find").Params(predicateCode).Id(typeName).
		Block(jen.Id("return si.FirstOrDefault(predicate)"))
	// #endregion Find
	jenFile.Line()

	// #region FindAll
	jenFile.Comment("FindAll retrieves all the elements that match the conditions defined by the specified predicate")

	jenFile.Func().Call(jen.Id(fmt.Sprint("si ", linqableTypeName))).Id("FindAll").Params(predicateCode).Id(linqableTypeName).
		Block(jen.Id("return si.Where(predicate)"))
	// #endregion FindAll
	jenFile.Line()

	// #region FindIndex
	jenFile.Commentf("FindIndex searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire %s.", linqableTypeName)

	jenFile.Func().Call(jen.Id(fmt.Sprint("si ", linqableTypeName))).Id("FindIndex").Params(predicateCode).Id("int").
		Block(jen.For(jen.Id("i, elem := range si")).
			Block(jen.If(jen.Id("predicate(elem)")).
				Block(jen.Return(jen.Id("i")))).
			Line().Return(jen.Id("-1")))
	// #endregion FindIndex
	jenFile.Line()

	// #region FindLast
	jenFile.Commentf("FindLast searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire %s.", linqableTypeName)

	jenFile.Func().Call(jen.Id(fmt.Sprint("si ", linqableTypeName))).Id("FindLast").Params(predicateCode).Id(typeName).
		Block(jen.Id("return si.LastOrDefault(predicate)"))
	// #endregion FindLast
	jenFile.Line()

	// #region FindLastIndex
	jenFile.Commentf("FindLastIndex searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire %s.", linqableTypeName)

	jenFile.Func().Call(jen.Id(fmt.Sprint("si ", linqableTypeName))).Id("FindLastIndex").Params(predicateCode).Id("int").
		Block(jen.Id("res := -1").
			Line().For(jen.Id("i, elem := range si")).
			Block(jen.If(jen.Id("predicate(elem)")).
				Block(jen.Id("res = i"))).
			Line().Return(jen.Id("res")))
	// #endregion FindLastIndex
	jenFile.Line()

	// #region ForEach
	jenFile.Commentf("ForEach executes the provided callback once for each element present in the %s in ascending order.", linqableTypeName)

	jenFile.Func().Call(jen.Id(fmt.Sprint("si ", linqableTypeName))).Id("ForEach").Params(jen.Id("callBack").Func().Params(jen.Id(typeName))).
		Block(jen.For(jen.Id("_, elem := range si")).
			Block(jen.Id("callBack(elem)")))
	// #endregion ForEach
	jenFile.Line()

	// #region ReplaceAll
	jenFile.Commentf("ReplaceAll replaces all oldValues with newValues in the %s", linqableTypeName)

	jenFile.Func().Call(jen.Id(fmt.Sprint("si ", linqableTypeName))).Id("ReplaceAll").Params(jen.Id(fmt.Sprint("oldValue, newValue ", typeName))).Id(linqableTypeName).
		Block(jen.Id(fmt.Sprintf("res := New%s([]%s{})", linqableTypeName, typeName)).
			Line().For(jen.Id("_, elem := range si")).
			Block(jen.If(jen.Id("reflect.DeepEqual(elem, oldValue)")).
				Block(jen.Id("res = res.Append(newValue)")).Else().
				Block(jen.Id("res = res.Append(elem)"))).
			Line().Return(jen.Id("res")))
	// #endregion ReplaceAll
	jenFile.Line()

	// #region Remove
	jenFile.Commentf("Remove removes the first occurrence of a specific object from the %s.", linqableTypeName)

	jenFile.Func().Call(jen.Id(fmt.Sprint("si *", linqableTypeName))).Id("Remove").Params(jen.Id(fmt.Sprint("item ", typeName))).Id("bool").
		Block(jen.Id(fmt.Sprintf("res := New%s([]%s{})", linqableTypeName, typeName)).
			Line().Id("var isRemoved bool").
			Line().For(jen.Id("_, elem := range *si")).
			Block(jen.If(jen.Id("reflect.DeepEqual(elem, item) && !isRemoved")).
				Block(jen.Id("isRemoved = true").
					Line().Op("continue")).
				Line().Id("res = res.Append(elem)")).
			Line().Id("*si = res").
			Line().Return(jen.Id("isRemoved")))
	// #endregion Remove
	jenFile.Line()

	// #region RemoveAll
	jenFile.Comment("RemoveAll removes all the elements that match the conditions defined by the specified predicate.")

	jenFile.Func().Call(jen.Id(fmt.Sprint("si *", linqableTypeName))).Id("RemoveAll").Params(predicateCode).Id("int").
		Block(jen.Id("var count int").
			Line().Id(fmt.Sprintf("res := New%s([]%s{})", linqableTypeName, typeName)).
			Line().For(jen.Id("_, elem := range *si")).
			Block(jen.If(jen.Id("predicate(elem)")).
				Block(jen.Id("count++").
					Line().Op("continue")).
				Line().Id("res = res.Append(elem)")).
			Line().Id("*si = res").
			Line().Return(jen.Id("count")))
	// #endregion RemoveAll
	jenFile.Line()

	// #region RemoveAt
	jenFile.Commentf("RemoveAt removes the element at the specified index of the %s.", linqableTypeName)

	jenFile.Func().Call(jen.Id(fmt.Sprint("si *", linqableTypeName))).Id("RemoveAt").Params(jen.Id("index int")).
		Block(jen.Id(fmt.Sprintf("res := New%s([]%s{})", linqableTypeName, typeName)).
			Line().For(jen.Id("i := 0; i < len(*si); i++")).
			Block(jen.If(jen.Id("i == index")).
				Block(jen.Op("continue")).
				Line().Id("res = res.Append((*si)[i])")).
			Line().Id("*si = res"))
	// #endregion RemoveAt
	jenFile.Line()

	// #region RemoveRange
	jenFile.Commentf("RemoveRange removes a range of elements from the %s.", linqableTypeName)

	jenFile.Func().Call(jen.Id(fmt.Sprint("si *", linqableTypeName))).Id("RemoveRange").Params(jen.Id("index, count int")).Id("error").
		Block(jen.If(jen.Id("index < 0 || count < 0 || index+count > len(*si)")).
			Block(jen.Return(jen.Id(`fmt.Errorf("argument out of range")`))).
			Line().Id(fmt.Sprintf("res := New%s([]%s{})", linqableTypeName, typeName)).
			Line().For(jen.Id("i := 0; i < len(*si); i++")).
			Block(jen.If(jen.Id("i >= index && count != 0")).
				Block(jen.Id("count--").
					Line().Op("continue")).
				Line().Id("res = res.Append((*si)[i])")).
			Line().Id("*si = res").
			Line().Return(jen.Id("nil")))
	// #endregion RemoveRange
	jenFile.Line()

	jenFile.Comment("#endregion not linq")

	file, err := os.Create(fmt.Sprintf("linqable_%s.go", t.Name()))
	if err != nil {
		fmt.Println(err)
	}
	defer file.Close()
	file.WriteString(fmt.Sprintf("%#v", jenFile))
}

// LinqablizeOptionFunc : optional parameters of Linqablize()
type LinqablizeOptionFunc func(*linqablizeOption)
type linqablizeOption struct {
	isImportedType  bool
	isNumericType   bool
	hasDefaultValue bool
	defaultValue    string
}

// IsImportedType : optional parameter for the Linqablize()
//
// output file will import the package of the specified type
func IsImportedType() LinqablizeOptionFunc {
	return func(lo *linqablizeOption) {
		lo.isImportedType = true
	}
}

// IsNumericType : optional parameter for the Linqablize()
//
// output file will contain the methods such as Max(), Min() ...
func IsNumericType() LinqablizeOptionFunc {
	return func(lo *linqablizeOption) {
		lo.isNumericType = true
	}
}

// HasDefaultValue : Set the default value of your type, or the default value will be the zero value
//
// Default value should be passed as string. for example : HasDefaultValue(`MyStruct{myInt: 0,myString: "hello world"}`).
// Notice that sometimes you should pass a value with type conversion like HasDefaultValue("int64(8888)")
func HasDefaultValue(stringValue string) LinqablizeOptionFunc {
	return func(lo *linqablizeOption) {
		lo.hasDefaultValue = true
		lo.defaultValue = stringValue
	}
}
